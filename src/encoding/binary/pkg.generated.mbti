// Generated using `moon info`, DON'T EDIT IT
package "tonyfettes/go/encoding/binary"

import(
  "tonyfettes/go/io"
  "tonyfettes/go/slice"
)

// Values
let native_endian : ByteOrder

fn[T : Readable] read(&@io.Reader, ByteOrder) -> T raise

fn[T : ReadableN] read_n(&@io.Reader, ByteOrder, Int) -> T raise

fn[T : Sized] size(T) -> Int

// Errors

// Types and methods
type BigEndian
impl Show for BigEndian
impl ToJson for BigEndian
impl AppendByteOrder for BigEndian
impl IByteOrder for BigEndian

pub(all) enum ByteOrder {
  LittleEndian
  BigEndian
}
fn ByteOrder::append_uint16(Self, @slice.Slice[Byte], UInt16) -> @slice.Slice[Byte]
fn ByteOrder::append_uint32(Self, @slice.Slice[Byte], UInt) -> @slice.Slice[Byte]
fn ByteOrder::append_uint64(Self, @slice.Slice[Byte], UInt64) -> @slice.Slice[Byte]
fn ByteOrder::put_uint16(Self, @slice.Slice[Byte], UInt16) -> Unit
fn ByteOrder::put_uint32(Self, @slice.Slice[Byte], UInt) -> Unit
fn ByteOrder::put_uint64(Self, @slice.Slice[Byte], UInt64) -> Unit
fn ByteOrder::uint16(Self, @slice.Slice[Byte]) -> UInt16
fn ByteOrder::uint32(Self, @slice.Slice[Byte]) -> UInt
fn ByteOrder::uint64(Self, @slice.Slice[Byte]) -> UInt64
impl Show for ByteOrder
impl ToJson for ByteOrder

type LittleEndian
impl Show for LittleEndian
impl ToJson for LittleEndian
impl AppendByteOrder for LittleEndian
impl IByteOrder for LittleEndian

// Type aliases

// Traits
pub trait AppendByteOrder {
  append_uint16(Self, @slice.Slice[Byte], UInt16) -> @slice.Slice[Byte]
  append_uint32(Self, @slice.Slice[Byte], UInt) -> @slice.Slice[Byte]
  append_uint64(Self, @slice.Slice[Byte], UInt64) -> @slice.Slice[Byte]
}

pub trait IByteOrder : Show + ToJson {
  uint16(Self, @slice.Slice[Byte]) -> UInt16
  uint32(Self, @slice.Slice[Byte]) -> UInt
  uint64(Self, @slice.Slice[Byte]) -> UInt64
  put_uint16(Self, @slice.Slice[Byte], UInt16) -> Unit
  put_uint32(Self, @slice.Slice[Byte], UInt) -> Unit
  put_uint64(Self, @slice.Slice[Byte], UInt64) -> Unit
}

pub(open) trait Readable {
  read(&@io.Reader, ByteOrder) -> Self raise
}
impl Readable for Byte
impl Readable for Int
impl Readable for Int16
impl Readable for Int64
impl Readable for UInt
impl Readable for UInt16
impl Readable for UInt64

pub(open) trait ReadableN {
  read(&@io.Reader, ByteOrder, Int) -> Self raise
}
impl[T : Readable + Default] ReadableN for FixedArray[T]
impl[T : Readable + Default] ReadableN for Array[T]
impl[T : Readable + Default] ReadableN for @slice.Slice[T]

pub(open) trait Sized {
  size() -> Int
}
impl Sized for UInt16

