// Generated using `moon info`, DON'T EDIT IT
package "tonyfettes/go/encoding/binary"

import(
  "tonyfettes/go/io"
  "tonyfettes/go/slice"
)

// Values
let big_endian : BigEndian

let little_endian : LittleEndian

let native_endian : LittleEndian

fn[T : Readable] read(&@io.Reader, &ByteOrder) -> T raise

fn[T : ReadableN] read_n(&@io.Reader, &ByteOrder, Int) -> T raise

fn[T : Sized] size(T) -> Int

// Errors

// Types and methods
type BigEndian
impl Show for BigEndian
impl ToJson for BigEndian
impl AppendByteOrder for BigEndian
impl ByteOrder for BigEndian

type LittleEndian
impl Show for LittleEndian
impl ToJson for LittleEndian
impl AppendByteOrder for LittleEndian
impl ByteOrder for LittleEndian

// Type aliases

// Traits
pub trait AppendByteOrder {
  append_uint16(Self, @slice.Slice[Byte], UInt16) -> @slice.Slice[Byte]
  append_uint32(Self, @slice.Slice[Byte], UInt) -> @slice.Slice[Byte]
  append_uint64(Self, @slice.Slice[Byte], UInt64) -> @slice.Slice[Byte]
}

pub trait ByteOrder : Show + ToJson {
  uint16(Self, @slice.Slice[Byte]) -> UInt16
  uint32(Self, @slice.Slice[Byte]) -> UInt
  uint64(Self, @slice.Slice[Byte]) -> UInt64
  put_uint16(Self, @slice.Slice[Byte], UInt16) -> Unit
  put_uint32(Self, @slice.Slice[Byte], UInt) -> Unit
  put_uint64(Self, @slice.Slice[Byte], UInt64) -> Unit
}

pub(open) trait Readable {
  read(&@io.Reader, &ByteOrder) -> Self raise
}
impl Readable for Byte
impl Readable for Int
impl Readable for Int16
impl Readable for Int64
impl Readable for UInt
impl Readable for UInt16
impl Readable for UInt64

pub(open) trait ReadableN {
  read(&@io.Reader, &ByteOrder, Int) -> Self raise
}
impl[T : Readable + Default] ReadableN for FixedArray[T]
impl[T : Readable + Default] ReadableN for Array[T]
impl[T : Readable + Default] ReadableN for @slice.Slice[T]

pub(open) trait Sized {
  size() -> Int
}
impl Sized for UInt16

