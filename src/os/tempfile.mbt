///|
fn next_random() -> String {
  let uv = try! uv.unwrap_or_error()
  let buf = Bytes::make(4, 0)
  let _ = try! uv.random(buf, 0, _ => (), _ => ())
  try! uv.run(Default)
  let value : UInt = buf[0].to_uint() |
    (buf[1].to_uint() << 8) |
    (buf[2].to_uint() << 16) |
    (buf[3].to_uint() << 24)
  value.to_string()
}

///|
/// `create_temp` creates a new temporary file in the directory dir,
/// opens the file for reading and writing, and returns the resulting file.
/// The filename is generated by taking pattern and adding a random string to the end.
/// If pattern includes a `*`, the random string replaces the last `*`.
/// The file is created with mode 0o600 (before umask).
/// If dir is the empty string, `create_temp` uses the default directory for temporary files, as returned by [TempDir].
/// Multiple programs or goroutines calling `create_temp` simultaneously will not choose the same file.
/// The caller can use the file's Name method to find the pathname of the file.
/// It is the caller's responsibility to remove the file when it is no longer needed.
pub fn create_temp(dir : String, pattern : String) -> File raise {
  let dir = if dir == "" { temp_dir() } else { dir }
  let (prefix, suffix) = prefix_and_suffix(pattern) catch {
    err => raise @fs.PathError::new(op="createtemp", path=pattern, err)
  }
  let prefix = join_path(dir, prefix)
  let mut try_ = 0
  for {
    let name : String = [..prefix, ..next_random(), ..suffix]
    let f = open_file(name, O_RDWR | O_CREATE | O_EXCL, 0o600) catch {
      err => {
        if is_exist(err) {
          try_ = try_ + 1
          if try_ < 10000 {
            continue
          }
          raise @fs.PathError::new(
            op="createtemp",
            path=[..prefix, '*', ..suffix],
            err,
          )
        }
        raise err
      }
    }
    return f
  }
}

///|
priv suberror PatternHasSeparator

///|
fn prefix_and_suffix(pattern : String) -> (StringView, StringView) raise {
  for c in pattern {
    if is_path_separator(c) {
      raise PatternHasSeparator
    }
  }
  if pattern.rev_find("*") is pos && pos is Some(pos) {
    return (try! pattern[0:pos], try! pattern[pos + 1:])
  } else {
    return (pattern, "")
  }
}

///|
pub fn join_path(dir : String, name : StringView) -> String {
  if sysname is "Windows_NT" {
    if dir is [.., '\\' | '/'] {
      return [..dir, ..name]
    } else {
      return [..dir, '\\', ..name]
    }
  } else if dir is [.., '/'] {
    return [..dir, ..name]
  } else {
    return [..dir, '/', ..name]
  }
}
