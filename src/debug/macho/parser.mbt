///|
fn File::parse(data : @slice.Slice[Byte]) -> File raise {
  if data.length() < 4 {
    raise FormatError::FileTooSmall(actual_size=data.length(), required_size=4)
  }
  let magic = read_uint(data, 0, Little)
  let byte_order = match determine_byte_order(magic) {
    Some(order) => order
    None => raise FormatError::InvalidMagic(magic~)
  }
  let magic = read_uint(data, 0, byte_order)
  let header = FileHeader::parse(data, byte_order, magic)
  parse_file_with_header(data, header, byte_order)
}

///|
fnalias @builtin.int64

///|
fnalias @builtin.uint64

///|
fnalias @builtin.uint as uint32

///|
fnalias @builtin.int

///|
fnalias @builtin.len

///|
fn cstring(b : @slice.Slice[Byte]) -> String {
  let mut i = @bytes.index_byte(b, 0)
  if i == -1 {
    i = len(b)
  }
  return @utf8.decode_lossy(b[0:i])
}


///|
fn FileHeader::parse(
  data : @slice.Slice[Byte],
  byte_order : ByteOrder,
  magic : UInt,
) -> FileHeader raise {
  let header_size = if magic == Magic64 {
    FileHeaderSize64
  } else {
    FileHeaderSize32
  }
  if data.length() < header_size {
    raise FormatError::FileTooSmall(
      actual_size=data.length(),
      required_size=header_size,
    )
  }
  let cpu = Cpu::from_uint(read_uint(data, 4, byte_order))
  let sub_cpu = read_uint(data, 8, byte_order)
  let type_ = Type::from_uint(read_uint(data, 12, byte_order))
  let ncmd = read_uint(data, 16, byte_order)
  let cmdsz = read_uint(data, 20, byte_order)
  let flags = read_uint(data, 24, byte_order)
  { magic, cpu, sub_cpu, type_, ncmd, cmdsz, flags }
}

///|
fn parse_file_with_header(
  data : @slice.Slice[Byte],
  header : FileHeader,
  byte_order : ByteOrder,
) -> File raise {
  let header_size = if header.magic == Magic64 {
    FileHeaderSize64
  } else {
    FileHeaderSize32
  }
  if header_size.reinterpret_as_uint() + header.cmdsz >
    data.length().reinterpret_as_uint() {
    raise FormatError::CommandDataOverflow(
      offset=header_size,
      size=header.cmdsz,
      file_size=data.length(),
    )
  }
  let cmd_data = read_bytes(
    data,
    header_size,
    header.cmdsz.reinterpret_as_int(),
  )
  let (loads, sections, symtab, dysymtab) = parse_load_commands(
    cmd_data,
    byte_order,
    header.ncmd,
  )
  let final_symtab = match symtab {
    Some(st) => {
      let is_64bit = header.magic == Magic64
      Some(Symtab::parse(data, st, is_64bit, byte_order)) catch {
        _ => Some(st) // Fall back to original symtab if parsing fails
      }
    }
    None => None
  }
  { header, byte_order, loads, sections, symtab: final_symtab, dysymtab, closer: None }
}

///|
fn parse_load_commands(
  data : @slice.Slice[Byte],
  byte_order : ByteOrder,
  ncmd : UInt,
) -> (Array[LoadCommand], Array[Section], Symtab?, Dysymtab?) raise {
  let loads = Array::new()
  let sections = Array::new()
  let mut symtab : Symtab? = None
  let mut dysymtab : Dysymtab? = None
  let mut offset = 0
  let mut cmd_count = 0_U
  while cmd_count < ncmd && offset + 8 <= data.length() {
    let cmd = LoadCmd::from_uint(read_uint(data, offset, byte_order))
    let siz = read_uint(data, offset + 4, byte_order)
    if siz < 8_U || offset + siz.reinterpret_as_int() > data.length() {
      raise ParseError::InvalidCommandSize(offset~, size=siz)
    }
    let cmddat = read_bytes(data, offset, siz.reinterpret_as_int())
    match cmd {
      LoadCmd::Segment => {
        let (segment, segment_sections) = Segment32::parse(cmddat, byte_order)
        loads.push(LoadCommand::Segment(segment))
        for section in segment_sections {
          sections.push(section)
        }
      }
      LoadCmd::Segment64 => {
        let (segment, segment_sections) = Segment64::parse(cmddat, byte_order)
        loads.push(LoadCommand::Segment(segment))
        for section in segment_sections {
          sections.push(section)
        }
      }
      LoadCmd::Symtab => {
        let st = SymtabCmd::parse(cmddat, byte_order)
        loads.push(LoadCommand::Symtab(st))
        symtab = Some(st)
      }
      LoadCmd::Dysymtab => {
        let dst = DysymtabCmd::parse(cmddat, byte_order)
        loads.push(LoadCommand::Dysymtab(dst))
        dysymtab = Some(dst)
      }
      LoadCmd::Dylib => {
        let dylib = DylibCmd::parse(cmddat, byte_order)
        loads.push(LoadCommand::Dylib(dylib))
      }
      LoadCmd::Rpath => {
        let rpath = RpathCmd::parse(cmddat, byte_order)
        loads.push(LoadCommand::Rpath(rpath))
      }
      _ => loads.push(LoadCommand::LoadBytes(LoadBytes(cmddat)))
    }
    offset = offset + siz.reinterpret_as_int()
    cmd_count = cmd_count + 1_U
  }
  (loads, sections, symtab, dysymtab)
}

///|
pub fn File::new(data : @slice.Slice[Byte]) -> File raise {
  File::parse(data)
}

///|
pub fn open_file(path : String) -> File raise {
  let data = @fs.read_file_to_bytes(path)
  File::parse(@slice.bytes(data))
}

///|
fn Symtab::parse(
  file_data : @slice.Slice[Byte],
  symtab : Symtab,
  is_64bit : Bool,
  byte_order : ByteOrder,
) -> Symtab raise {
  let symdata_offset = symtab.symtab_cmd.symoff.reinterpret_as_int()
  let string_table_offset = symtab.symtab_cmd.stroff.reinterpret_as_int()
  let string_table_size = symtab.symtab_cmd.strsize.reinterpret_as_int()
  let symdata = read_bytes(
    file_data,
    symdata_offset,
    symtab.symtab_cmd.nsyms.reinterpret_as_int() * (if is_64bit { 16 } else { 12 }),
  )
  let strtab = read_bytes(file_data, string_table_offset, string_table_size)
  let symbols = parse_symbols(
    symdata,
    strtab,
    symtab.symtab_cmd.nsyms,
    is_64bit,
    byte_order,
  )
  {
    load_bytes: symtab.load_bytes,
    symtab_cmd: symtab.symtab_cmd,
    syms: symbols,
  }
}
