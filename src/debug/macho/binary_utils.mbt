///|
fn read_uint(
  data : @slice.Slice[Byte],
  offset : Int,
  byte_order : ByteOrder,
) -> UInt raise {
  if offset + 4 > data.length() {
    raise BufferOverflowError::ReadOverflow(
      offset~,
      length=4,
      buffer_size=data.length(),
      operation="read_uint",
    )
  }
  match byte_order {
    Little =>
      data[offset].to_uint() |
      (data[offset + 1].to_uint() << 8) |
      (data[offset + 2].to_uint() << 16) |
      (data[offset + 3].to_uint() << 24)
    Big =>
      (data[offset].to_uint() << 24) |
      (data[offset + 1].to_uint() << 16) |
      (data[offset + 2].to_uint() << 8) |
      data[offset + 3].to_uint()
  }
}

///|
fn read_uint64(
  data : @slice.Slice[Byte],
  offset : Int,
  byte_order : ByteOrder,
) -> UInt64 raise {
  if offset + 8 > data.length() {
    raise BufferOverflowError::ReadOverflow(
      offset~,
      length=8,
      buffer_size=data.length(),
      operation="read_uint64",
    )
  }
  let low = read_uint(data, offset, byte_order).to_uint64()
  let high = read_uint(data, offset + 4, byte_order).to_uint64()
  match byte_order {
    Little => low | (high << 32)
    Big => high | (low << 32)
  }
}

///|
fn read_bytes(
  data : @slice.Slice[Byte],
  offset : Int,
  length : Int,
) -> @slice.Slice[Byte] raise {
  if offset + length > data.length() {
    raise BufferOverflowError::ReadOverflow(
      offset~,
      length~,
      buffer_size=data.length(),
      operation="read_bytes",
    )
  }
  data[offset:offset + length]
}

///|
fn determine_byte_order(magic : UInt) -> ByteOrder? {
  if magic == Magic32 || magic == Magic64 {
    Some(Little)
  } else if magic == 0xfacefeed_U || magic == 0xcffaedfe_U {
    Some(Big)
  } else {
    None
  }
}

///|
fn read_cstring(
  data : @slice.Slice[Byte],
  offset : Int,
) -> @slice.Slice[Byte] raise {
  if offset >= data.length() {
    raise BufferOverflowError::ReadOverflow(
      offset~,
      length=1,
      buffer_size=data.length(),
      operation="read_cstring",
    )
  }
  let mut end = offset
  while end < data.length() && data[end] != 0 {
    end = end + 1
  }
  data[offset:end]
}

///|
fn @slice.Slice::contains(self : @slice.Slice[Byte], byte : Byte) -> Bool {
  loop self.bytesview() {
    [b, ..] if b == byte => true
    [_, .. rest] => continue rest
    [] => false
  }
}
